## Execute this for as long as you want to check we no longer get
## errors and to compare against OncoSimulR.


library(evamtools)
library(testthat)
data(all_examples_csd)

## Real data
data(every_which_way_data)

rdd <- list(
    Dat1 = every_which_way_data[[2]][1:50, 1:4]
  , Dat2 = every_which_way_data[[4]][1:50, 1:5]
  , Dat3 = every_which_way_data[[20]][1:50, 1:5]
  , Dat4 = every_which_way_data[[16]][1:40, 2:6]
  , Dat5 = every_which_way_data[[2]][ , 1:7]
  , Dat6 = every_which_way_data[[4]][1:60, 1:7]
  , Dat7 = every_which_way_data[[20]][, 1:7]
  , Dat8 = every_which_way_data[[16]][, 1:7]
)

rdd_processed <- lapply(rdd, function(z) {
    tmp <- evamtools:::df_2_mat_integer(z)
    tmp <- evamtools:::pre_process(tmp, remove.constant = FALSE)
    return(tmp)
})

iters <- 1
s <- sample(1:1e6, size = 1)

while(TRUE) {
    cat("\n Seed = ", s, ". Doing iteration ", iters, "\n")
    set.seed(s)
    ## Recall evamtools:::cpm2tm <- cpm_to_trans_mat_oncosimul

    ## For testing
    reorder_trans_mat <- function(x) {
        gg <- c(1, 1 + order(colnames(x)[-1]))
        return(as.matrix(x[gg, gg]))
    }

    run_test_for_dataset <- function(data) {
        ## Used in several places. Run just once
        cpm2_out <- evamtools:::cpm2tm(data$edges, max_f = NULL)
        if(min(data$edges$Lambda) < 1e-15) {
            warning("Skipping comparison with OncoSimul's ",
                    "transition rate matrix: ",
                    "smallest lambda < 1e-15")
            ## We compute products of numbers close to R's smallest limit.
            ## We are probably fine with numbers even as small as 2e-16, but to be safe.
        } else if (sum(data$edges$Lambda < 1e-10) >= 1) {
          warning("Skipping comparison with OncoSimul's ",
                  "numerical values of transition rate matrix: ",
                  "one or more lambdas < 1e-10.",
                  " Comparing only sets of accessible genotypes")
          cno <- colnames(reorder_trans_mat(cpm2_out$transition_matrix))
          cnd <- colnames(
              reorder_trans_mat(evamtools:::cpm_access_genots_paths_w_simplified_relationships(                                              data)$trans_mat_genots))
          expect_true(all(cno == cnd))
        } else {
            expect_equal(
            reorder_trans_mat(cpm2_out$transition_matrix),
            reorder_trans_mat(evamtools:::cpm_access_genots_paths_w_simplified_relationships(
                                              data)$trans_mat_genots),
            check.attributes = TRUE)
        }

        ## Do not run next test if fitness is absurdly large as scaling will fail
        ## (as it should).  Do not run it either if ratio of largest to smallest
        ## lambda is > 1e9 as in products we accumulate tiny errors that give
        ## differences of the order of 1e-8.
        max_fitness <- max(cpm2_out$accessible_genotypes)
        ratio_lambdas <- max(data$edges$Lambdas)/min(data$edges$Lambdas)
        if((max_fitness < 1e10) && (ratio_lambdas < 1e9))  {
            maxff <- sample(c(2, 3, 3.5, 3.8, 4, 5, 8), size = 1)
            this_tolerance <- testthat_tolerance()
            if(min(data$edges$Lambdas) < 1e-5) {
                warning("Smallest lambda < 1e-5. Setting tolerance to 1e-6 ",
                        "for numerical comparison of transition rates ",
                        "between max_f = NULL and max_f = maxff")
                this_tolerance <- 1e-6
            }
            expect_equal(as.matrix(cpm2_out$transition_matrix),
                         as.matrix(evamtools:::cpm2tm(data$edges, max_f = maxff)$transition_matrix),
                         tolerance = this_tolerance
                         )
            rm(this_tolerance)
        } else {
            warning("Skipping comparison of transition matrices with ",
                    "different fitness scaling",
                    ifelse(max_fitness >= 1e10, ". max_fitness >= 1e10", ""),
                    ifelse(ratio_lambdas >= 1e9, ". Ratio of Lambdas >= 1e9", ""))
        }
    }
    
    ## First, load a bunch of data structures
    ## Adapted from test.OT-CBN-trans-mat-against-oncosimul.R
    ## ex_hesbcn_*: output from running evam:::do_HESBCN with examples_csd
    ## examples_csd: list of cross sectional data sets
    ## examples_csd: is located in file /data/all_examples_csd.RData
    ## examples_csd: is generated by script inst/miscell/toy_datasets.R

    ## Output from running evamtools:::do_HESBCN(examples_csd$csd$AND$data)

   
    ## Run HESBCN.
    ex_hesbcn_and <- evamtools:::do_HESBCN(examples_csd$csd$AND$data, seed = s)
    ex_hesbcn_linear <- evamtools:::do_HESBCN(examples_csd$csd$Linear$data, seed = s)
    ex_hesbcn_or <- evamtools:::do_HESBCN(examples_csd$csd$OR$data, seed = s)
    ex_hesbcn_xor <- evamtools:::do_HESBCN(examples_csd$csd$XOR$data, seed = s)
    ex_hesbcn_c1 <- evamtools:::do_HESBCN(examples_csd$csd$c1$data, seed = s)
    ex_hesbcn_c3 <- evamtools:::do_HESBCN(examples_csd$csd$c3$data, seed = s)
    ex_hesbcn_c4c2 <- evamtools:::do_HESBCN(examples_csd$csd$c4c2$data, seed = s)

   
    
    all_examples <- list(ex_hesbcn_and, ex_hesbcn_linear, ex_hesbcn_or, ex_hesbcn_xor,
        ex_hesbcn_c1, ex_hesbcn_c3, ex_hesbcn_c4c2)

    

    for(i in seq_along(all_examples)) {
        cat("\n Doing all_examples number ", i, "\n")
        run_test_for_dataset(all_examples[[i]])
    }


    ## Create two data sets that tend to lead to combination of AND, OR, XOR,
    ## Single.

    ## And if you thought CBN was unstable and sometimes counterintuitive ... try
    ## HESBCN :-)
    
    set.seed(s)
    d1 <- data.frame(A = sample(c(1, 0), prob = c(0.7, 0.2), size = 200, replace = TRUE),
                     B = sample(c(1, 0), prob = c(0.85, 0.2), size = 200, replace = TRUE))
    d1$C <- 0
    d1$D <- 0
    d1$E <- 0
    d1$F <- 0
    d1$C[(d1$A == 1) & (d1$B == 1)] <- 1
    d1$D[(d1$A == 1) | (d1$B == 1)] <- 1
    d1$D[100:200] <- 0
    d1$E[xor((d1$A == 1), (d1$B == 1))] <- 1
    d1$F[(d1$C == 1) & (d1$D == 1)] <- 1
    d2 <- rbind(d1,
                data.frame(A = sample(c(1, 0), size = 25, prob = c(0.5, 0.2), replace = TRUE),
                           B = sample(c(1, 0), size = 25, prob = c(0.5, 0.2), replace = TRUE),
                           C = 0,
                           D = sample(c(1, 0), size = 25, replace = TRUE),
                           E = 0,
                           F = 0))
    d3 <- d2
    d3$C[(d3$A == 1) & (d3$B == 1)] <- 1
    

    d111 <- data.frame(A = sample(c(1, 0), prob = c(0.7, 0.2), size = 2000, replace = TRUE),
                     B = sample(c(1, 0), prob = c(0.85, 0.2), size = 2000, replace = TRUE))
    d111$C <- 0
    d111$D <- 0
    d111$E <- 0
    d111$F <- 0
    d111$C[(d111$A == 1) & (d111$B == 1)] <- 1
    d111$D[(d111$A == 1) | (d111$B == 1)] <- 1
    d111$D[100:200] <- 0
    d111$E[xor((d111$A == 1), (d111$B == 1))] <- 1
    d111$F[(d111$C == 1) & (d111$D == 1)] <- 1
    d222 <- rbind(d111,
                data.frame(A = sample(c(1, 0), size = 250, prob = c(0.5, 0.2), replace = TRUE),
                           B = sample(c(1, 0), size = 250, prob = c(0.5, 0.2), replace = TRUE),
                           C = 0,
                           D = sample(c(1, 0), size = 25, replace = TRUE),
                           E = 0,
                           F = 0))
    d333 <- d222
    d333$C[(d333$A == 1) & (d333$B == 1)] <- 1

    set.seed(NULL)
    
    ## Examples that mix output
    d3_1 <- evamtools:::do_HESBCN(d3, seed = s) ## AND, OR,XOR, Single with some seeds
    d3_2 <- evamtools:::do_HESBCN(d3, seed = s)
    d3_3 <- evamtools:::do_HESBCN(d3, seed = s)
    d333_2 <- evamtools:::do_HESBCN(d333, seed = s) ## single, OR, XOR, AND with some seeds

    all_mixed_examples <- list(d3_1, d3_2, d3_3, d3_3, d333_2)
    
    for(ex in all_examples){
        run_test_for_dataset(ex)
    }
    set.seed(NULL)
    

    ## Real data sets
    ## Doesn't give us much, since most are Single
    ## But for a long running test, this is OK
    cat("\n Running rdd analysis \n")
    out_rdd <- lapply(rdd_processed,
                      function(d) evamtools:::do_HESBCN(d, seed = s))

    for(i in seq_along(out_rdd)) {
        cat("\n Comparing rdd number ", i, "\n")
        run_test_for_dataset(out_rdd[[i]])
    }

    iters <- iters + 1
    s <- s + 1
}

